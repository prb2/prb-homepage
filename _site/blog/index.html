<!DOCTYPE html>
<html lang="en">
	<head>
			<link href="../css/bootstrap.css" rel="stylesheet">
			<script src="//use.typekit.net/iko5qge.js"></script>
			<link href='http://fonts.googleapis.com/css?family=Lato:100,300' rel='stylesheet' type='text/css'>
			<script>try{Typekit.load();}catch(e){}</script>
	</head>

	<style>
		a {
			color: #485b77;
			text-decoration: underline;
		}
		a:hover {
			color: #8296b4;
			text-decoration: underline;
		}
		body {
			font-size: 18px;
			line-height: 30px;
			margin-top: 2%;
			margin-bottom: 2%;
		}
		hr {
			border-width: 1.5px;
			border-color: black;
		}
		p {
			margin-top: 20px;
			margin-bottom: 20px
		}
		.title {
			font-size: 30px;
			font-weight: 200;
			margin-top: 5px;
			margin-bottom: 5px;
		}

		.posttitle {
			font-size: 25px;
			font-weight: 200;
			margin-top: 5px;
			margin-bottom: 5px;
		}
		.subtitle {
			font-size: 23px;
			font-weight: 200;
			margin-top: 40px;
			margin-bottom: 20px;
		}
		.serif {
			font-family: "adobe-garamod-pro";
		}
	</style>
	<body>

		<div class="container-fluid">
			<div class="col-md-2 col-md-offset-1 sidebar">
				<style>
		th {
			font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
			font-weight: 100;
			font-size:	72px;
		}
		td {
			font-family: Lato, Helvetica, Arial, sans-serif;
			font-weight:	300;
			font-size:	25px;
		}

		.sidelink {
			text-decoration: none !important;
		}
</style>

<row>
	<table class="table">
		<thead>
			<th><a class="sidelink" href="../index.html">pb</a></th>
		</thead>

		<tbody>
			<tr><td><a class="sidelink" href="../">home</a></td></tr>

			<tr><td><a class="sidelink" href="../projects/">projects</a></td></tr>

			<tr><td><a class="sidelink" href="../blog/">blog</a></td></tr>

			<tr><td><a class="sidelink" href="../photography/">photography</a></td></tr>

			<tr><td><a class="sidelink" href="http://www.github.com/prb2">github</a></td></tr>

			<tr><td><a class="sidelink" href="mailto:prrb02@gmail.com">email</a></td></tr>

			<tr><td></td></tr>
		</tbody>
	</table>
</row>

			</div>

			<div class="col-md-6 col-md-offset-1">
				<div class="title">Blog</div>
				<hr>
				
	</br>
	19 Jul 2015
	</br>
	<div class="posttitle">OMPL Web Development - Part 5</div>
	</br>
	<p>Benchmarking planners is a time consuming process, so instead of waiting on the
webpage to see the results, users submit jobs and are notified when the results
become available. This process is handled by <a href="http://www.celeryproject.org">Celery</a>,
an asynchronous task queue implemented in Python. When a benchmarking job is
submitted, it is given to a Celery worker to execute, freeing up the Flask
server to continue to serve other requests. Using Celery for benchmarking was
fairly simple to setup since the client doesn't need any information from the
completed job.</p>

<p><img src="" class="img-responsive"></p>

<p>However, solving a motion planning problem can also take a large
amount of time; solving them synchronously would be impractical.</p>

<div class="subtitle">Asynchronous Solving</div>


<p>The problem with making regular motion planning asynchronous is that the user
waits for the solution. For asynchronous solving to work, there must be
some amount of coordination between the client and server to ensure that the
right results are returned to the right user.</p>

<p><img src="../images/omplweb/async_solving.png" class="img-responsive"></p>

<p>To solve this problem, I came up with the pattern seen above. When the user
submits a motion planning problem, the task is assigned to a Celery worker and
the ID of that task is immediately returned to the client. Then, the client
will preiodically poll the server for the results.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno"> 1</span> <span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/omplapp/poll/&lt;task_id&gt;&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;POST&#39;</span><span class="p">])</span>
<span class="lineno"> 2</span> <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="n">task_id</span><span class="p">):</span>
<span class="lineno"> 3</span>     <span class="sd">&quot;&quot;&quot;</span>
<span class="lineno"> 4</span> <span class="sd">    Checks if the task corresponding to the input ID has completed. If the</span>
<span class="lineno"> 5</span> <span class="sd">    task is done solving, the solution is returned.</span>
<span class="lineno"> 6</span> <span class="sd">    &quot;&quot;&quot;</span>
<span class="lineno"> 7</span>     
<span class="lineno"> 8</span>     <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Recieved poll for task: &quot;</span> <span class="o">+</span> <span class="n">task_id</span><span class="p">)</span>
<span class="lineno"> 9</span>     
<span class="lineno">10</span>     <span class="n">result</span> <span class="o">=</span> <span class="n">solve</span><span class="o">.</span><span class="n">AsyncResult</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
<span class="lineno">11</span>     
<span class="lineno">12</span>     <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ready</span><span class="p">():</span>
<span class="lineno">13</span>         <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()),</span> <span class="mi">200</span>
<span class="lineno">14</span>     <span class="k">else</span> <span class="p">:</span>
<span class="lineno">15</span>         <span class="k">return</span> <span class="s">&quot;Result for task id: &quot;</span> <span class="o">+</span> <span class="n">task_id</span> <span class="o">+</span> <span class="s">&quot; isn&#39;t ready yet.&quot;</span><span class="p">,</span> <span class="mi">202</span></code></pre></div>



	</br>
	<hr>

	</br>
	07 Jul 2015
	</br>
	<div class="posttitle">OMPL Web Development - Part 4</div>
	</br>
	<p>With problem configuration and visualization implemented, the next big
feature is benchmarking.</p>

<div class="subtitle">Benchmarking</div>


<h4>Motivation</h4>

<p>Benchmarking is an important feature of OMPL Web that does not exist in its
desktop counterpart. Since each planner has a unique way of finding solutions,
different planners may be better suited for different types of problems. For
this reason, it is important to know when to use a specific
planner. By benchmarking multiple planners on a given problem, we can compare
each planner's performance across various metrics such as time, memory, solution
length, etc.</p>

<p>Furthermore, since the planners are all sampling-based, the problem can be
solved repeatedly to get consistent data.</p>

<p><img src="../images/omplweb/benchmarking.png" class="img-responsive"></p>

<h4>Implementation</h4>

<p>The benchmarking functionality of OMPL Web allows a user to
solve any given problem <code>n</code> times with multiple planners and various planner
configurations. On the <code>Benchmarking</code> page, the user can add and configure the
planners to be benchmarked. Then, they can submit a job to the server
and be notified via email when the job completes.</p>

<p>When the user submits a job, a <code>.cfg</code> file is created on the client-side
containing all of the problem configuration details and benchmarking settings.
This information is sent to the server for processing. The server processes this
data using the benchmarking scripts included in OMPL and creates a SQLite
database of results. Currently, this (very small) database is emailed to the
user. This database file can be uploaded to <a href="http://plannerarena.org">Planner
Arena</a> for an interactive visualization of the
results.</p>

<p>In the future, the benchmarking results will be made available to the user
directly on <a href="http://plannerarena.org">Planner Arena</a>
without the need for the user to obtain the database file.</p>

<p><a href="https://github.com/prb2/omplweb">OMPL Web on GitHub</a></p>

<p><a href="http://ompl.kavrakilab.org">Open Motion Planning Library</a></p>


	</br>
	<hr>

	</br>
	07 Jul 2015
	</br>
	<div class="posttitle">OMPL Web Development - Part 3</div>
	</br>
	<div class="subtitle">Visualization</div>


<p>Once a motion planning problem has been solved, the user is presented with
several options for visualizing the solution. Initially, a line is displayed
indicating the path from the start position to the goal position. The user can
then toggle an animation of the robot and adjust its speed as it travels from
its starting position to the goal. In addition, a static visualization
consisting of robots placed at points along the solution path is also available.</p>

<p><img src="../images/omplweb/solution_anim.jpg" class="img-responsive"></p>

<center>A "path robot" (top left) travels from the start position (bottom left) to the goal position (bottom-right).</center>


<p><img src="../images/omplweb/solution_static.jpg" class="img-responsive"></p>

<center>A static view of the robot's orientation at each point along the
solution path.</center>


<p>The user can interact with the visualiztion using the mouse. Left-clicking and
dragging will rotate the environment while right-clicking and dragging will pan.
The visualization was constructed with <a href="https://www.khronos.org/webgl/">WebGL</a>
using the <a href="http://threejs.org">THREE.js</a> library.</p>


	</br>
	<hr>

	</br>
	16 Jun 2015
	</br>
	<div class="posttitle">OMPL Web Development - Part 2</div>
	</br>
	<p>Significant progress has been made in the past week or so and the application looks
and behaves very differently than before. Furthermore, the user interface has
been completely overhauled to accommodate new features and look cleaner.</p>

<p><img src="../images/omplweb/existing.png" class="img-responsive"></p>

<div class="subtitle">Design & Functionality</div>


<p>The biggest change in terms of the interface is the addition of the visualization
to the configuration page. Now, the robot's position will be updated to reflect
any changes the user makes in the configuration panel. When the problem has
been configured to the user's liking and solved, the solution path (if one was
found) will be drawn and animated.</p>

<p>The visualization is being built primarily using
<a href="https://www.khronos.org/webgl/">WebGL</a> with the <a href="http://threejs.org/">three.js</a>
library.</p>

<p>If the user selects an existing problem from the <code>Problem</code> drop down menu, a
request is sent to the server to retrieve that problem's configuration
information and its robot and environment models. The configuration fields are
then filled in with the information from the server and the models are loaded and
drawn. The screenshot above is state of the interface when an existing problem has
been selected.</p>

<p>If the user selects a custom problem from the <code>Problem</code> drop
down menu, then the sidebar will expand to reveal options for uploading custom
robot and environment models and, optionally, a configuration file. Once these
files have been selected, the will be uploaded to the server and drawn, as seen
in the screenshot below.</p>

<p><img src="../images/omplweb/custom.png" class="img-responsive"></p>

<p>The <code>Planner</code> tab allows the user to select which planner to use for solving
the problem. When a planner is selected, the default values for that planner's
parameters are retrieved from the server and displayed. The user can edit these
options if they wish. The <code>Bounds</code> tab allows the user to modify the bounding
box for the problem, if they are dissatisfied with the default values for that
environment.</p>

<p>Finally, from <code>Solve</code> tab, the user can name the problem and specify a time
limit for solving the problem. If all the required fields are satisfied, they
can click the solve button and await the results. At this point the problem is
sent to the server for processing. When the results are returned, the
information is displayed within the pane. If a successful solution path was
found, it will be drawn and the robot will be animated traveling the path. This
animation is still in development.</p>

<p><a href="https://github.com/prb2/omplweb">OMPL Web on GitHub</a></p>

<p><a href="http://ompl.kavrakilab.org">Open Motion Planning Library</a></p>


	</br>
	<hr>

	</br>
	08 Jun 2015
	</br>
	<div class="posttitle">OMPL Web Development - Part 1</div>
	</br>
	<p>This summer, I am working in the <a href="http://www.kavrakilab.org">Kavraki Lab</a>
research group at Rice University. My main project this summer will be to
create a web application that will allow users to solve motion planning
problems for robots using the Open Motion Planning Library.</p>

<p>An existing application, called
<a href="http://ompl.kavrakilab.org/gui.html">OMPL.app</a>, is available for desktop clients
but it involves a fairly lengthy installation process. The purpose of the web
application is to provide all of the features of the desktop application and
then some. Users will be able to configure a motion planning problem and solve
for a solution path. Upon success, the solution will be displayed and the user
will be able to interact with the path. The functionality described thus far
already exists in OMPL.app, but the web application will have several key
improvements.</p>

<div class="subtitle">Speed</div>


<p>One of primary motivations for creating the web version is to drastically
reduce the time it takes to go from being interested in motion planning to
actually creating and solving motion planning problems. The
following steps must be carried out before solving a motion planning problem:</p>

<blockquote><p>OMPL.app</p>

<ol>
<li>Download the OMPL library and its dependencies</li>
<li>Install all dependencises</li>
<li>Build OMPL</li>
<li>Generate Python bindings</li>
<li>Run OMPL.app</li>
</ol>


<p>OMPL Web</p>

<ol>
<li>Open the website</li>
</ol>
</blockquote>

<p>OMPL.app can take hours to setup; the web implementation will take mere seconds.</p>

<div class="subtitle">Benchmarking</div>


<p>The other important improvement will be planner benchmarking. OMPL takes a
sample-based approach to motion planning and there exist many planners for
utilizing different sampling methods. In addition to the dozen or so planners
that are available within OMPL, users can create their own planners and use
those instead. Due to the significant variation in how planners operate,
selecting a particular planner may yield better results for a specific query
than some other planner. For this reason it is important to have the ability to
compare the results of different planners for a given problem. Currently,
planners can be compared on the <a href="http://plannerarena.org">Planner Arena</a> website.</p>

<p>Once a user is satisfied with their problem configuration on the OMPL Web
application, they will be able to submit a job to the server
for benchmarking. They can specify benchmarking parameters such as
the number of iterations to run each planner, time limits, etc. When the job is
completed, the user will be notified and their results will be available
on Planner Arena for analysis.</p>

<p>In the next development blog entry, I will discuss the work that I've completed
so far and the high level plan for the remaining development.</p>

<p><a href="https://github.com/prb2/omplweb">OMPL Web on GitHub</a></p>

<p><a href="http://ompl.kavrakilab.org">Open Motion Planning Library</a></p>


	</br>
	<hr>

	</br>
	31 May 2015
	</br>
	<div class="posttitle">Scheller's Place</div>
	</br>
	<p><a href="https://www.flickr.com/photos/125510902@N05/17673362234"
title="DSC00763_Processed by Prudhvi Boyapalli, on Flickr"><img
src="https://c1.staticflickr.com/9/8804/17673362234_d072b5457a_b.jpg"
width="1024" height="680" class="img-responsive" alt="DSC00763_Processed"></a></p>

<center>Glen Flora, Texas - Jan. 24, 2015</center>


<p><br></p>

<p>I took this photo in the small town of Glen Flora, about an hour southwest of
Houston. Over the course of this past Spring semester, I spent time
photographing the Colorado and Brazos rivers. This photo was taken on my first
trek, when I visited the Colorado River. In the map below, you can see the Colorado just to the
left of the town itself.</p>

<p><br></p>

<iframe width='100%' height='450px' frameBorder='0'
src='https://a.tiles.mapbox.com/v4/violethill0704.mapnhe4g/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoidmlvbGV0aGlsbDA3MDQiLCJhIjoiZmZkY0otQSJ9.3S1CVMzIsLOJjetgQope9Q'></iframe>





	</br>
	<hr>

	</br>
	14 May 2015
	</br>
	<div class="posttitle">W</div>
	</br>
	<p>Ever since I started using Vim regularly, I find myself looking for ways to do
more things from the command line. So, today I set out to write a basic command
line program for viewing the weather. W is a python script that displays
weather data for a given location and timeframe. I'm sure there are many like
it, but this one is mine.</p>

<p></br></p>

<p>The script is invoked like this: <code>$ ./w.py &lt;city&gt; &lt;option&gt;</code></p>

<p>Where <code>&lt;option&gt;</code> can be:</p>

<p><code>today</code> displays today's weather</p>

<p><code>tomorrow</code> displays tomorrow's weather</p>

<p><code>week</code> displays a five day forecast</p>

<p><code>sun</code> displays sunrise and sunset times</p>

<p><code>wind</code> displays current wind conditions</p>

<p></br></p>

<p>Take a look at the <a href="http://prb2.github.io/weather"><u>project page</u></a>
for details on installation and usage.</p>


	</br>
	<hr>


			</div>
		</div>
	</body>
</html>
